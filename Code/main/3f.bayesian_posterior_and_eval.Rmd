---
title: "3f. Bayesian Posterior Distributions and Repeated-Field Evaluation"
author: "Jaeseok Hwang"
format:
  html:
    toc: true
    code-fold: true
execute:
  echo: true
  warning: true
  message: true
---


# Set up 
```{r setup}

library(dplyr)
library(tidyr)
library(purrr)
library(ggplot2)
library(readr)
library(tibble)
library(here)
library(nleqslv)

analysis_dir    <- here("Data","Processed","Analysis_ready")
apsim_ready_dir <- here("Data","Processed","APSIP_compare_ready")

normalize_region <- function(x) sub("^[0-9]+-", "", x)
region_levels <- c("North","Central","South")
```



# -------------------------------------------------------------------
# Core objects from previous steps
# -------------------------------------------------------------------
```{r load}

# OFPE cluster-level moments (from 3c)
ofpe_moments_il <- readRDS(
  file.path(apsim_ready_dir, "ofpe_moments_il.rds")
)

# APSIM prior moments at same cells (from 3c) – not strictly needed here
apsim_prior_moments_il <- readRDS(
  file.path(apsim_ready_dir, "apsim_prior_moments_il.rds")
) %>%
  mutate(
    region = normalize_region(region),
    region = factor(region, levels = region_levels)
  )

# Mapping field-year to APSIM cell/region (used elsewhere in book)
ofpe_il_cells <- readRDS(
  file.path(apsim_ready_dir, "ofpe_il_cells.rds")
) %>%
  mutate(region = normalize_region(region))

# County benchmarks (if you need them later)
field_benchmarks <- readRDS(
  here("Data","Processed","NASS","field_benchmarks.rds")
)

# Field meta (farm, field, year, ffy_id, stusps, etc.)
field_loc2 <- readRDS(file.path(analysis_dir, "field_loc2.rds"))

# Posterior moment table from 3e (must contain mu1_post, mu2_post, mu3_prior, etc.)
bayes_moments_il <- readRDS(
  file.path(apsim_ready_dir, "bayes_moments_il.rds")
) %>%
  mutate(
    region = normalize_region(region),
    region = factor(region, levels = region_levels)
  )

# Optimal N rules from 3e (prior / OFPE / posterior optimal N per field-year)
opt_N_il <- readRDS(
  file.path(apsim_ready_dir, "opt_N_prior_ofpe_post_il.rds")
)

dplyr::glimpse(ofpe_moments_il)
dplyr::glimpse(bayes_moments_il)
dplyr::glimpse(opt_N_il)

```


# Part 1. Maximum-Entropy Posterior Yield Distributions (MBME)

```{r mbme posterior}

# Region-specific support ranges for yields

region_support <- tibble::tibble(
region = c("North","Central","South"),
y_min = c(120, 140, 100),
y_max = c(300, 320, 280)
)

# solve MaxEnt exponential-polynomial density

solve_mbme <- function(mu1, mu2, mu3, y_min, y_max, n_grid = 400) {

y <- seq(y_min, y_max, length.out = n_grid)

# target raw moments

m1_target <- mu1
m2_target <- mu1^2 + mu2
m3_target <- mu1^3 + 3 * mu1 * mu2 + mu3

moment_eq <- function(par) {
a <- par[1]; b <- par[2]; c <- par[3]
f_unnorm <- exp(a * y + b * y^2 + c * y^3)
Z <- sum(f_unnorm)
p <- f_unnorm / Z
m1 <- sum(y * p)
m2 <- sum(y^2 * p)
m3 <- sum(y^3 * p)
c(m1 - m1_target,
m2 - m2_target,
m3 - m3_target)
}
# nonlinear solver (simple starting values)

sol <- nleqslv::nleqslv(c(0, -1e-4, 0), moment_eq)

if (sol$termcd != 1) {
warning("MBME solver did not fully converge; using raw solution anyway.")
}

a <- sol$x[1]; b <- sol$x[2]; c <- sol$x[3]
f_unnorm <- exp(a * y + b * y^2 + c * y^3)
f <- f_unnorm / sum(f_unnorm)

tibble(
y = y,
density = f
)
}


# Construct posterior MBME density for each ffy_id × N

bayes_moments_il <- bayes_moments_il %>%
mutate(
mu3_post = mu3_prior # Using APSIM skewness as posterior skewness
)

mbme_list <- bayes_moments_il %>%
group_split(ffy_id, N_fert) %>%
map(function(df1) {

df_row <- df1[1,]

reg <- as.character(df_row$region)
srow <- region_support %>% filter(region == reg)

if (nrow(srow) == 0) {
  warning("No region support for region = ", reg, "; skipping.")
  return(NULL)
}

y_min <- srow$y_min
y_max <- srow$y_max

res <- try(
  solve_mbme(
    mu1   = df_row$mu1_post,
    mu2   = df_row$mu2_post,
    mu3   = df_row$mu3_post,
    y_min = y_min,
    y_max = y_max,
    n_grid = 400
  ),
  silent = TRUE
)

if (inherits(res, "try-error") || is.null(res)) {
  warning("MBME failed for ffy_id = ", df_row$ffy_id,
          ", N_fert = ", df_row$N_fert)
  return(NULL)
}

res %>%
  mutate(
    ffy_id = df_row$ffy_id,
    farm   = df_row$farm,
    field  = df_row$field,
    year   = df_row$year,
    region = df_row$region,
    N_fert = df_row$N_fert
  )

})

mbme_post_il <- mbme_list %>%
compact() %>% # drop NULLs
bind_rows()

dplyr::glimpse(mbme_post_il)

# Save posterior densities for use in ridge plots, etc.

saveRDS(
mbme_post_il,
file = file.path(apsim_ready_dir, "mbme_posterior_yield_density_il.rds")
)

```

# Example posterior density plot for one field-year × N

```{r plot posterior}

example_ffy <- dplyr::first(mbme_post_il$ffy_id)
example_N <- mbme_post_il %>%
filter(ffy_id == example_ffy) %>%
summarise(N_min = min(N_fert)) %>%
pull(N_min)

ggplot(
mbme_post_il %>% filter(ffy_id == example_ffy, N_fert == example_N),
aes(x = y, y = density)
) +
geom_line(color = "blue") +
labs(
title = paste0("Posterior MBME density: field ", example_ffy,
", N = ", round(example_N, 1), " lb/ac"),
x = "Yield (bu/ac)",
y = "Density"
) +
theme_minimal()

```


# Repeated-Field Evaluation of N Rules (Year1 → Year2)

- evaluate how APSIM prior, OFPE-only, and posterior N rules perform out-of-sample on the next year of the same field.
```{r replicated trial}

# Build repeated-field pairs

field_il <- field_loc2 %>%
filter(stusps == "IL") %>%
arrange(farm, field, year)

# sequential Year1 → Year2 pairs within farm–field

field_pairs_il <- field_il %>%
group_by(farm, field) %>%
arrange(year, .by_group = TRUE) %>%
filter(n() >= 2) %>%
mutate(
ffy_id_next = lead(ffy_id),
year_next = lead(year)
) %>%
filter(!is.na(ffy_id_next)) %>%
ungroup()

field_pairs_il

saveRDS(
field_pairs_il,
file = file.path(apsim_ready_dir, "field_pairs_il.rds")
)


# Attach Year1 N rules and prepare Year2 OFPE curves

# keep only N choices from opt_N_il

opt_N_il_small <- opt_N_il %>%
select(
ffy_id,
N_opt_prior,
N_opt_ofpe,
N_opt_post
)

pair_rules_il <- field_pairs_il %>%
left_join(
opt_N_il_small,
by = c("ffy_id")
)

pair_rules_il %>%
summarise(
n_pairs = n(),
n_missing_prior = sum(is.na(N_opt_prior)),
n_missing_ofpe = sum(is.na(N_opt_ofpe)),
n_missing_post = sum(is.na(N_opt_post))
)

# Year2 OFPE moments: rename for convenience

ofpe_moments_il2 <- ofpe_moments_il %>%
mutate(
N_fert = N_target,
mu1 = Y_ofpe_mean
)

dplyr::glimpse(ofpe_moments_il2)


# Helper functions for Year2 evaluation

# Fit quadratic Year2 yield curve

fit_year2_curve <- function(ffy_id2, df_moments = ofpe_moments_il2) {

df2 <- df_moments %>%
filter(ffy_id == ffy_id2)

if (nrow(df2) < 3 || all(!is.finite(df2$mu1))) {
return(NULL)
}

tryCatch(
{
model <- lm(mu1 ~ poly(N_fert, 2, raw = TRUE), data = df2)
list(
model = model,
N_min = min(df2$N_fert, na.rm = TRUE),
N_max = max(df2$N_fert, na.rm = TRUE)
)
},
error = function(e) {
message("Year2 curve fit failed for ffy_id2 = ", ffy_id2,
" with error: ", e$message)
NULL
}
)
}

yield_at <- function(model, N_vec) {
predict(model, newdata = data.frame(N_fert = N_vec))
}

profit_at <- function(Y, N, p_yield = 5, p_N = 0.9) {
p_yield * Y - p_N * N
}

clamp_N <- function(N, N_min, N_max) {
pmax(pmin(N, N_max), N_min)
}


```

# Evaluate each pair (Year1 rule on Year2 curve)

```{r replicated trial}

eval_one_pair <- function(pair_row,
df_moments = ofpe_moments_il2,
p_yield = 5,
p_N = 0.9) {

ffy_id1 <- pair_row$ffy_id
year1 <- pair_row$year
ffy_id2 <- pair_row$ffy_id_next
year2 <- pair_row$year_next
farm <- pair_row$farm
field <- pair_row$field

N_prior1 <- pair_row$N_opt_prior
N_ofpe1 <- pair_row$N_opt_ofpe
N_post1 <- pair_row$N_opt_post

# Fit Year2 curve

fit_obj <- fit_year2_curve(ffy_id2, df_moments = df_moments)
if (is.null(fit_obj)) {
return(
tibble(
farm = farm,
field = field,
ffy_id1 = ffy_id1,
year1 = year1,
ffy_id2 = ffy_id2,
year2 = year2,
N_prior1 = N_prior1,
N_ofpe1 = N_ofpe1,
N_post1 = N_post1,
N_prior2 = NA_real_,
N_ofpe2 = NA_real_,
N_post2 = NA_real_,
Y_prior2 = NA_real_,
Y_ofpe2 = NA_real_,
Y_post2 = NA_real_,
pi_prior2 = NA_real_,
pi_ofpe2 = NA_real_,
pi_post2 = NA_real_,
N_opt_true2 = NA_real_,
Y_opt_true2 = NA_real_,
pi_opt_true2 = NA_real_,
regret_prior = NA_real_,
regret_ofpe = NA_real_,
regret_post = NA_real_
)
)
}

model2 <- fit_obj$model
N_min2 <- fit_obj$N_min
N_max2 <- fit_obj$N_max

# Clamp N rules into Year2 support

N_prior2 <- clamp_N(N_prior1, N_min2, N_max2)
N_ofpe2 <- clamp_N(N_ofpe1, N_min2, N_max2)
N_post2 <- clamp_N(N_post1, N_min2, N_max2)

# Yields & profits under each rule

Y_prior2 <- as.numeric(yield_at(model2, N_prior2))
Y_ofpe2 <- as.numeric(yield_at(model2, N_ofpe2))
Y_post2 <- as.numeric(yield_at(model2, N_post2))

pi_prior2 <- profit_at(Y_prior2, N_prior2, p_yield, p_N)
pi_ofpe2 <- profit_at(Y_ofpe2, N_ofpe2, p_yield, p_N)
pi_post2 <- profit_at(Y_post2, N_post2, p_yield, p_N)

#Ex-post optimal N on Year2 curve

N_seq <- seq(N_min2, N_max2, length.out = 200)
Y_seq <- yield_at(model2, N_seq)
pi_seq <- profit_at(Y_seq, N_seq, p_yield, p_N)
idx_opt <- which.max(pi_seq)

N_opt_true2 <- N_seq[idx_opt]
Y_opt_true2 <- Y_seq[idx_opt]
pi_opt_true2 <- pi_seq[idx_opt]

regret_prior <- pi_opt_true2 - pi_prior2
regret_ofpe <- pi_opt_true2 - pi_ofpe2
regret_post <- pi_opt_true2 - pi_post2

tibble(
farm = farm,
field = field,
ffy_id1 = ffy_id1,
year1 = year1,
ffy_id2 = ffy_id2,
year2 = year2,
N_prior1 = N_prior1,
N_ofpe1 = N_ofpe1,
N_post1 = N_post1,
N_prior2 = N_prior2,
N_ofpe2 = N_ofpe2,
N_post2 = N_post2,
Y_prior2 = Y_prior2,
Y_ofpe2 = Y_ofpe2,
Y_post2 = Y_post2,
pi_prior2 = pi_prior2,
pi_ofpe2 = pi_ofpe2,
pi_post2 = pi_post2,
N_opt_true2 = N_opt_true2,
Y_opt_true2 = Y_opt_true2,
pi_opt_true2 = pi_opt_true2,
regret_prior = regret_prior,
regret_ofpe = regret_ofpe,
regret_post = regret_post
)
}

# Apply to all pairs

pair_eval_il <- pair_rules_il %>%
mutate(row_id = row_number()) %>%
split(.$row_id) %>%
map_dfr(eval_one_pair)

pair_eval_il

pair_eval_il %>%
summarise(
n_pairs = n(),
n_valid = sum(is.finite(regret_post)),
mean_regret_prior = mean(regret_prior, na.rm = TRUE),
mean_regret_ofpe = mean(regret_ofpe, na.rm = TRUE),
mean_regret_post = mean(regret_post, na.rm = TRUE)
)

saveRDS(
pair_eval_il,
file = file.path(apsim_ready_dir, "pair_eval_il.rds")
)

```