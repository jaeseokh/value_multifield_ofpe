---
title: "Tree Models — Leave-One-Location-Out (LOLO)"
format:
  html:
    toc: true
    toc-depth: 3
---

```{r setup, include=FALSE}
library(here)
knitr::opts_chunk$set(message = FALSE, warning = FALSE)

suppressPackageStartupMessages({
  library(dplyr); library(tidyr); library(ggplot2); library(purrr); library(readr)
})

source(here::here("Code/src/functions_for_trees.R"))
## Config (set parameters)
```


```{r config}

# Paths & toggles
data_path <- here::here("Data","Processed","Analysis_ready","stacked_analysis_table.rds")
out_base  <- here::here("Data","Processed","Models_LOLO")

use_rf    <- TRUE
use_xgb   <- TRUE
use_gam   <- TRUE      # <-- mgcv baseline on test field only
n_points  <- 40


 rf_hp <- list(
  num.trees       = 100,     # still quick
  mtry            = NULL,
  min.node.size   = 5,       # was 50 — too big for small n
  max.depth       = 6,
  sample.fraction = 1.0,     # ensure at least 1 obs sampled
  replace         = TRUE,    # default, but set explicitly
  importance      = "impurity",
  seed            = 123
)


 xgb_hp <- list(eta = 0.05, max_depth = 3, min_child_weight = 30, gamma = 4, subsample = 0.6,
 colsample_bytree = 0.6, lambda = 3.0, alpha = 0.0, nrounds = 200, monotone = TRUE)


# RF / XGB hyperparameters (fast defaults)
#  ultra-fast test version RF

rf_hp_test <- list(
  num.trees       = 50,     # 200 -> 50
  mtry            = 2,      # small feature subsample
  min.node.size   = 100,    # big leaves
  max.depth       = 4,      # shallow trees
  sample.fraction = 0.5,    # fewer rows per tree
  importance = "impurity",
  seed            = 123
)

# Ultra-fast XGB (still monotone on n_rate)
xgb_hp_test <- list(
  eta               = 0.10, # faster learning
  max_depth         = 2,    # 3-> 2very shallow
  min_child_weight  = 50,   # 30 -> 50 strong smoothing
  gamma             = 5,  
  subsample         = 0.5,
  colsample_bytree  = 0.5,
  lambda            = 4.0,
  alpha             = 0.0,
  nrounds           = 60,   # 200 -> 60
  monotone          = TRUE
)


# Columns
y_var <- "yield"
n_col <- "n_rate"
x_vars <- c("n_rate","elev","slope","aspect","TPI",
            "clay","sand","water_storage","prcp_t","gdd_t","edd_t")

# Economic scenarios
corn_price_default <- 5.0
n_price_default    <- 0.8
n_price_multipliers <- c(0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8)

scenarios <- tibble::tibble(
  scenario_id = paste0("Nmult_", gsub("\\.","p", sprintf("%.1f", n_price_multipliers))),
  corn_price  = corn_price_default,
  n_price     = n_price_default * n_price_multipliers
)

dir.create(out_base, recursive = TRUE, showWarnings = FALSE)

```

## Load combined data & remove N-rate outliers (1.5 SD, global)

```{r load}

df0 <- readRDS(data_path)
stopifnot(y_var %in% names(df0), n_col %in% names(df0))
stopifnot(all(x_vars %in% names(df0)))

n_vals <- df0[[n_col]]
n_mu   <- mean(n_vals, na.rm = TRUE)
n_sd   <- sd(n_vals,   na.rm = TRUE)
n_lower <- n_mu - 1.5 * n_sd
n_upper <- n_mu + 1.5 * n_sd

n_before <- nrow(df0)
df <- df0 %>% dplyr::filter(.data[[n_col]] >= n_lower, .data[[n_col]] <= n_upper)
message(sprintf("N-rate screen ±1.5 SD: kept %d/%d (%.1f%%). Range: [%.2f, %.2f].",
                nrow(df), n_before, 100*nrow(df)/n_before, n_lower, n_upper))

df <- df %>% add_farm_field(ffy_col = "ffy_id", out_col = "farm_field")

names(df) <- trimws(names(df))
x_vars    <- trimws(x_vars)
stopifnot(y_var %in% names(df), n_col %in% names(df), all(x_vars %in% names(df)))

```

## Choose holdouts: focus first on multi-year farm_fields

```{r choose-holdouts}

df_unique <- df %>% dplyr::distinct(farm_field, ffy_id)

ff_counts <- df_unique %>%
  dplyr::count(farm_field, name = "num_years") %>%
  dplyr::arrange(desc(num_years))

multi_ff <- ff_counts %>%
  dplyr::filter(num_years >= 2) %>%
  dplyr::pull(farm_field)

holdout_table <- df_unique %>%
  dplyr::filter(farm_field %in% multi_ff) %>%
  dplyr::arrange(farm_field, ffy_id)

mapping_pretty <- holdout_table %>%
  dplyr::group_by(farm_field) %>%
  dplyr::summarise(
    n_years = dplyr::n_distinct(ffy_id),
    ffy_ids = paste(sort(unique(ffy_id)), collapse = ", "),
    .groups = "drop"
  ) %>% dplyr::arrange(farm_field)

print(mapping_pretty, n = Inf)

three_ff <- mapping_pretty %>% dplyr::filter(n_years >= 3) %>% dplyr::pull(farm_field)
holdouts_three <- holdout_table %>%
  dplyr::filter(farm_field %in% three_ff) %>%
  dplyr::arrange(farm_field, ffy_id) %>%
  dplyr::pull(ffy_id)

```

## Save artifacts & compute EONR

```{r helpers}

save_lolo_artifacts <- function(res, curve_all, out_base_dir = out_base) {
  dir <- file.path(out_base_dir, res$test_ffy_id)
  dir.create(dir, recursive = TRUE, showWarnings = FALSE)

  metrics <- res$holdout_metrics
  if (!is.null(res$gam)) metrics <- dplyr::bind_rows(metrics, res$gam$metrics)
  readr::write_csv(metrics, file.path(dir, "holdout_metrics.csv"))

  rf_fit  <- tryCatch(res$bundle$fits$RF,  error = function(e) NULL)
  xgb_fit <- tryCatch(res$bundle$fits$XGB, error = function(e) NULL)
  if (!is.null(rf_fit))  saveRDS(rf_fit,  file.path(dir, "rf_model.rds"))
  if (!is.null(xgb_fit)) saveRDS(xgb_fit, file.path(dir, "xgb_model.rds"))

  if (!is.null(rf_fit) && inherits(rf_fit, "ranger")) {
    ti <- ranger::treeInfo(rf_fit, tree = 1)
    readr::write_csv(ti, file.path(dir, "rf_tree1_edges.csv"))
    if (!is.null(rf_fit$variable.importance)) {
      vi <- tibble::tibble(feature = names(rf_fit$variable.importance),
                           importance = as.numeric(rf_fit$variable.importance))
      readr::write_csv(vi, file.path(dir, "rf_varimp.csv"))
    }
  }

  if (!is.null(xgb_fit) && inherits(xgb_fit, "xgb.Booster")) {
    dump_txt <- xgboost::xgb.dump(xgb_fit, with_stats = TRUE)
    writeLines(dump_txt, file.path(dir, "xgb_dump.txt"))
    feats <- tryCatch(res$bundle$meta$XGB_refcols, error = function(e) NULL)
    if (!is.null(feats)) {
      imp <- tryCatch(xgboost::xgb.importance(feature_names = feats, model = xgb_fit), error = function(e) NULL)
      if (!is.null(imp) && nrow(imp)) readr::write_csv(imp, file.path(dir, "xgb_varimp.csv"))
    }
  }

  readr::write_csv(curve_all, file.path(dir, "n_curves.csv"))
  invisible(dir)
}

compute_eonr_table <- function(curve_tbl, n_col, model_cols, scenarios_tbl) {
  purrr::map_dfr(seq_len(nrow(scenarios_tbl)), function(i) {
    cp <- scenarios_tbl$corn_price[i]
    np <- scenarios_tbl$n_price[i]
    sid <- scenarios_tbl$scenario_id[i]

    purrr::map_dfr(model_cols, function(m) {
      if (!m %in% names(curve_tbl)) return(NULL)
      dfm <- curve_tbl %>% dplyr::select(dplyr::all_of(c(n_col, m))) %>% dplyr::rename(yhat = !!m)
      dfm <- dfm %>% dplyr::filter(is.finite(.data[[n_col]]), is.finite(yhat))
      if (!nrow(dfm)) return(NULL)
      dfm <- dfm %>% dplyr::mutate(profit = cp * yhat - np * .data[[n_col]])
      best <- dfm[which.max(dfm$profit), , drop = FALSE]
      tibble::tibble(
        scenario_id    = sid,
        corn_price     = cp,
        n_price        = np,
        model          = m,
        EONR           = as.numeric(best[[n_col]]),
        yield_at_EONR  = as.numeric(best$yhat),
        profit_at_EONR = as.numeric(best$profit)
      )
    })
  })
}

```

## Run leave-one-location-out analysis

```{r run-multi}

message("3-trial farm_fields: ", length(unique(three_ff)),
        " | holdout field-years: ", length(holdouts_three))

for (id in holdouts_three) {
  message("\n==============================")
  message("LOLO (3-trial focus): ", id)
  art_dir <- file.path(out_base, id)

  if (file.exists(file.path(art_dir, "holdout_metrics.csv"))) {
    message("Skip (already exists): ", art_dir)
    next
  }

  test_df <- df[df$ffy_id == id, , drop = FALSE]
  miss_all  <- setdiff(x_vars, names(df))
  miss_test <- setdiff(x_vars, names(test_df))
  if (length(miss_all))  stop("Missing in FULL df: ", paste(miss_all, collapse = ", "))
  if (length(miss_test)) stop("Missing in TEST df: ", paste(miss_test, collapse = ", "))

  res <- lolo_run_once(
    df          = df,
    test_ffy_id = id,
    y_var       = y_var,
    x_vars      = x_vars,
    n_col       = n_col,
    use_rf      = use_rf,
    use_xgb     = use_xgb,
    rf          = rf_hp,
    xgb         = xgb_hp,
    n_points    = n_points,
    use_gam     = use_gam,     # <-- mgcv baseline
    gam_k       = 6,
    gam_smooth_others = FALSE
  )

  curve_all <- res$curve_table
if (!is.null(res$gam)) {
  curve_all <- dplyr::left_join(
    curve_all,
    res$gam$curves %>% dplyr::select(all_of(n_col), GAM),
    by = dplyr::join_by(!!rlang::sym(n_col))
  )
}

  saved_dir <- save_lolo_artifacts(res, curve_all, out_base_dir = out_base)
  message("Saved to: ", saved_dir)

  model_cols <- intersect(c("RF","XGB","GAM"), names(curve_all))
  eonr_tbl <- compute_eonr_table(curve_all, n_col, model_cols, scenarios)
  readr::write_csv(eonr_tbl, file.path(saved_dir, "eonr_table.csv"))

  message("Rendering curves and EONR table for: ", id)

  curve_long <- curve_all %>%
    tidyr::pivot_longer(cols = dplyr::all_of(model_cols),
                        names_to = "model", values_to = "yhat") %>%
    dplyr::filter(!is.na(yhat))

  print(
    ggplot(curve_long, aes(x = .data[[n_col]], y = yhat, color = model)) +
      geom_line(linewidth = 1) +
      labs(x = "Nitrogen rate", y = "Predicted yield",
           title = paste0("Yield–N curves (", id, ")"),
           color = "Model") +
      theme_minimal(base_size = 12)
  )

  print(eonr_tbl %>% dplyr::arrange(model, scenario_id))
}


```
