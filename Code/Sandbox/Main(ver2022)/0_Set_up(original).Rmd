---
title: "0. Set Up" 
author: "Jaeseok Hwang" 
date: "r Sys.Date()" 
output:
 html_document: default 
 pdf_document: default
 word_document: default
---




#   This script serves as the first step in the OFPE (On-Farm Precision 
#   Experimentation) data analysis pipeline. Its primary function is to 
#   prepare the R environment to ensure that the subsequent analysis scripts 
#   run smoothly and reproducibly. It automatically checks for all required R 
#   packages, installing any that are missing from the user's library.
#
#   Running this script before any others in the pipeline guarantees that all
#   dependencies are met, preventing errors due to missing packages.
#

# -----------------------------------------------------------------------------


```{r set up, cache = T, results = "hide"}

# List of required packages
required_packages <- c(
  # Core & Data Manipulation
  "here", "data.table", "tidyverse", "dplyr", "stringr", "jsonlite",
  "knitr", "rmarkdown", "magrittr", "measurements", "smoother", "bookdown",

  # Spatial Data Processing
  "sf", "stars", "raster", "terra", "exactextractr", "spatialEco",
  "elevatr", "soilDB", "FedData", "tmap",

  # Weather Data
  "daymetr",

  # Machine Learning & Modeling
  "mgcv",      # For GAM
  "caret",     # For data splitting
  "xgboost",   # For XGBoost
  "ranger",    # For Random Forest
  "grf",       # For Causal Forest
  "kernlab",   # For Gaussian Process (SVM/GP package)

  # Parallel Processing
  "parallel", "future", "future.apply"
)

# Identify packages that are not installed
missing_packages <- required_packages[!required_packages %in% installed.packages()[, "Package"]]

# Install missing packages
if (length(missing_packages) > 0) {
  cat("Installing missing packages:", paste(missing_packages, collapse = ", "), "\n")
  install.packages(missing_packages)
} else {
  cat("All required packages are already installed.\n")
}

# Load all packages for the session
cat("Loading packages...\n")
suppressPackageStartupMessages({
  invisible(lapply(required_packages, library, character.only = TRUE))
})

# --- Global Variables & Preparations from `0_Set_up_preparation.R` ---
# This section centralizes the initial setup steps.

cat("Defining global variables and loading price data...\n")

# Variable name definitions
vars_to_select <- c("obs_id", "yield", "seed_rate", "s_rate", "n_rate", "uan32_rate", "nh3_rate", "uan28_rate", "urea_rate")
vars_to_check <- c("seed_rate", "s_rate", "n_rate", "uan32_rate", "nh3_rate", "uan28_rate", "urea_rate")
field_reg_vars <- c('elev', 'slope', 'aspect', 'tpi', 'clay', 'sand', 'silt', 'water_storage')



# Function to safely convert to POSIXct using mdy_hms if necessary
convert_to_datetime <- function(time_value) {
  # Check if time_value is already in Date or POSIXct format
  if (inherits(time_value, "Date") | inherits(time_value, "POSIXct")) {
    return(time_value)  # Return as is if already in the correct format
  }
  
  # If time_value is logical or not in the correct format, use mdy_hms to convert
  if (is.logical(time_value) | is.character(time_value)) {
    tryCatch({
      return(mdy_hms(time_value))  # Attempt to convert using mdy_hms
    }, error = function(e) {
      return(NA)  # If conversion fails, return NA
    })
  }
  
  return(NA)  # Return NA if the type is unrecognized
}

### Price information (extract and calculate crop and input prices information from the raw data)

# 1. Extract the corn price-received by year
 corn_price_raw <- fread(here("Data","Raw","corn_price_received_by_year.csv"))
 
   corn_price_tab <- corn_price_raw[Period == "MARKETING YEAR",.(Year, Value)]
     
     setnames(corn_price_tab, "Value", "corn")
# 2. Extract the nitrogen price (N equivalent) by year

  n_price_raw <- fread(here("Data","Raw","nitrogen_fertilizer_prices.csv"))
 
  n_price_tab <- n_price_raw[!(Year %in% c("2014", "2015")), 
                      .(Year = as.numeric(Year), 
                        nitrogen = rowMeans(.SD, na.rm = TRUE)), 
                      .SDcols = 2:4]


# 3. Merge the corn price and seed cost information by year
price_tab <- merge(corn_price_tab, n_price_tab, , by = "Year")

price_tab <- price_tab %>% data.table() %>%
  setnames(tolower(names(price_tab)))


### Extract USDA reported annual average corn seed rates by state and year

# 1. read the US county map shape file
  us_map_sf <- st_read(here("Data","Raw","us_state_2023.shp"))  %>%
         st_transform(4326)
 
  # 2. sort out the state fips code for the states where experimental(ofpe) field are located
   ofpe_fips <- c(17, 18, 19, 20, 21, 26, 27, 29, 31, 38, 39, 46, 55)

    ofpe_sf <- us_map_sf %>%
               setnames(names(.), tolower(names(.))) %>%
               filter(statefp %in% ofpe_fips) %>% 
               mutate(fips = as.numeric(statefp)) %>%
               dplyr::select(fips,stusps)


cat("Setup complete.\n")


#  Read all field boundary polygons
bdry_files <- list.files(
  here("Data", "Raw", "exp_bdry_data"),
  pattern = "_bdry\\.rds$",
  full.names = TRUE
)

bdry_list <- lapply(bdry_files, readRDS)

# add a simple field_id from file name
for (i in seq_along(bdry_list)) {
  bdry_list[[i]]$field_id <- str_remove(basename(bdry_files[i]), "_bdry\\.rds$")
}

fields_sf <- do.call(rbind, bdry_list) %>%
  st_transform(st_crs(ofpe_sf))

# 3. Compute centroids for plotting / joining
field_centroids <- st_centroid(fields_sf)

# 5. Attach state info to each field (spatial join)
field_loc <- st_join(field_centroids, ofpe_sf, join = st_within) %>%
  st_drop_geometry() %>%
  dplyr::select(field_id, stusps, fips)

# 1. Extract farm / field / year from field_id
field_loc2 <- field_loc %>%
  mutate(field_id_clean = str_remove(field_id, "_bdry$")) %>%  # drop trailing "_bdry"
  separate(
    col   = field_id_clean,
    into  = c("farm", "field", "year"),
    sep   = "_",
    convert = TRUE,      # automatically to numeric where possible
    remove = FALSE
  )

# 1) First, summarize at farm–field level within each state
by_ff <- field_loc2 %>%
  group_by(stusps, farm, field) %>%
  summarise(
    n_years = n_distinct(year),   # how many years we have this farm–field
    .groups = "drop"
  )

# 2) Then, summarize at state level
state_summary <- by_ff %>%
  group_by(stusps) %>%
  summarise(
    n_trials_total      = sum(n_years),      # total farm–field–year units
    n_farm_field        = n(),              # number of unique farm–field combos
    n_repl_farm_field   = sum(n_years > 1), # farm–field combos with >1 year
    .groups = "drop"
  ) %>%
  arrange(stusps)

state_summary

```